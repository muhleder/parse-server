"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformTypes = void 0;

var _node = _interopRequireDefault(require("parse/node"));

var _graphqlRelay = require("graphql-relay");

var _filesMutations = require("../loaders/filesMutations");

var defaultGraphQLTypes = _interopRequireWildcard(require("../loaders/defaultGraphQLTypes"));

var objectsMutations = _interopRequireWildcard(require("../helpers/objectsMutations"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const transformTypes = async (inputType, fields, {
  className,
  parseGraphQLSchema,
  req
}) => {
  const {
    classGraphQLCreateType,
    classGraphQLUpdateType,
    config: {
      isCreateEnabled,
      isUpdateEnabled
    }
  } = parseGraphQLSchema.parseClassTypes[className];
  const parseClass = parseGraphQLSchema.parseClasses.find(clazz => clazz.className === className);

  if (fields) {
    const classGraphQLCreateTypeFields = isCreateEnabled && classGraphQLCreateType ? classGraphQLCreateType.getFields() : null;
    const classGraphQLUpdateTypeFields = isUpdateEnabled && classGraphQLUpdateType ? classGraphQLUpdateType.getFields() : null;
    const promises = Object.keys(fields).map(async field => {
      let inputTypeField;

      if (inputType === 'create' && classGraphQLCreateTypeFields) {
        inputTypeField = classGraphQLCreateTypeFields[field];
      } else if (classGraphQLUpdateTypeFields) {
        inputTypeField = classGraphQLUpdateTypeFields[field];
      }

      if (inputTypeField) {
        switch (true) {
          case inputTypeField.type === defaultGraphQLTypes.GEO_POINT_INPUT:
            fields[field] = transformers.geoPoint(fields[field]);
            break;

          case inputTypeField.type === defaultGraphQLTypes.POLYGON_INPUT:
            fields[field] = transformers.polygon(fields[field]);
            break;

          case inputTypeField.type === defaultGraphQLTypes.FILE_INPUT:
            fields[field] = await transformers.file(fields[field], req);
            break;

          case parseClass.fields[field].type === 'Relation':
            fields[field] = await transformers.relation(parseClass.fields[field].targetClass, field, fields[field], parseGraphQLSchema, req);
            break;

          case parseClass.fields[field].type === 'Pointer':
            fields[field] = await transformers.pointer(parseClass.fields[field].targetClass, field, fields[field], parseGraphQLSchema, req);
            break;
        }
      }
    });
    await Promise.all(promises);
    if (fields.ACL) fields.ACL = transformers.ACL(fields.ACL);
  }

  return fields;
};

exports.transformTypes = transformTypes;
const transformers = {
  file: async ({
    file,
    upload
  }, {
    config
  }) => {
    if (upload) {
      const {
        fileInfo
      } = await (0, _filesMutations.handleUpload)(upload, config);
      return {
        name: fileInfo.name,
        __type: 'File'
      };
    } else if (file && file.name) {
      return {
        name: file.name,
        __type: 'File'
      };
    }

    throw new _node.default.Error(_node.default.Error.FILE_SAVE_ERROR, 'Invalid file upload.');
  },
  polygon: value => ({
    __type: 'Polygon',
    coordinates: value.map(geoPoint => [geoPoint.latitude, geoPoint.longitude])
  }),
  geoPoint: value => _objectSpread({}, value, {
    __type: 'GeoPoint'
  }),
  ACL: value => {
    const parseACL = {};

    if (value.public) {
      parseACL['*'] = {
        read: value.public.read,
        write: value.public.write
      };
    }

    if (value.users) {
      value.users.forEach(rule => {
        parseACL[rule.userId] = {
          read: rule.read,
          write: rule.write
        };
      });
    }

    if (value.roles) {
      value.roles.forEach(rule => {
        parseACL[`role:${rule.roleName}`] = {
          read: rule.read,
          write: rule.write
        };
      });
    }

    return parseACL;
  },
  relation: async (targetClass, field, value, parseGraphQLSchema, {
    config,
    auth,
    info
  }) => {
    if (Object.keys(value) === 0) throw new _node.default.Error(_node.default.Error.INVALID_POINTER, `You need to provide at least one operation on the relation mutation of field ${field}`);
    const op = {
      __op: 'Batch',
      ops: []
    };
    let nestedObjectsToAdd = [];

    if (value.createAndAdd) {
      nestedObjectsToAdd = (await Promise.all(value.createAndAdd.map(async input => {
        const parseFields = await transformTypes('create', input, {
          className: targetClass,
          parseGraphQLSchema,
          req: {
            config,
            auth,
            info
          }
        });
        return objectsMutations.createObject(targetClass, parseFields, config, auth, info);
      }))).map(object => ({
        __type: 'Pointer',
        className: targetClass,
        objectId: object.objectId
      }));
    }

    if (value.add || nestedObjectsToAdd.length > 0) {
      if (!value.add) value.add = [];
      value.add = value.add.map(input => {
        const globalIdObject = (0, _graphqlRelay.fromGlobalId)(input);

        if (globalIdObject.type === targetClass) {
          input = globalIdObject.id;
        }

        return {
          __type: 'Pointer',
          className: targetClass,
          objectId: input
        };
      });
      op.ops.push({
        __op: 'AddRelation',
        objects: [...value.add, ...nestedObjectsToAdd]
      });
    }

    if (value.remove) {
      op.ops.push({
        __op: 'RemoveRelation',
        objects: value.remove.map(input => {
          const globalIdObject = (0, _graphqlRelay.fromGlobalId)(input);

          if (globalIdObject.type === targetClass) {
            input = globalIdObject.id;
          }

          return {
            __type: 'Pointer',
            className: targetClass,
            objectId: input
          };
        })
      });
    }

    return op;
  },
  pointer: async (targetClass, field, value, parseGraphQLSchema, {
    config,
    auth,
    info
  }) => {
    if (Object.keys(value) > 1 || Object.keys(value) === 0) throw new _node.default.Error(_node.default.Error.INVALID_POINTER, `You need to provide link OR createLink on the pointer mutation of field ${field}`);
    let nestedObjectToAdd;

    if (value.createAndLink) {
      const parseFields = await transformTypes('create', value.createAndLink, {
        className: targetClass,
        parseGraphQLSchema,
        req: {
          config,
          auth,
          info
        }
      });
      nestedObjectToAdd = await objectsMutations.createObject(targetClass, parseFields, config, auth, info);
      return {
        __type: 'Pointer',
        className: targetClass,
        objectId: nestedObjectToAdd.objectId
      };
    }

    if (value.link) {
      let objectId = value.link;
      const globalIdObject = (0, _graphqlRelay.fromGlobalId)(objectId);

      if (globalIdObject.type === targetClass) {
        objectId = globalIdObject.id;
      }

      return {
        __type: 'Pointer',
        className: targetClass,
        objectId
      };
    }
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9HcmFwaFFML3RyYW5zZm9ybWVycy9tdXRhdGlvbi5qcyJdLCJuYW1lcyI6WyJ0cmFuc2Zvcm1UeXBlcyIsImlucHV0VHlwZSIsImZpZWxkcyIsImNsYXNzTmFtZSIsInBhcnNlR3JhcGhRTFNjaGVtYSIsInJlcSIsImNsYXNzR3JhcGhRTENyZWF0ZVR5cGUiLCJjbGFzc0dyYXBoUUxVcGRhdGVUeXBlIiwiY29uZmlnIiwiaXNDcmVhdGVFbmFibGVkIiwiaXNVcGRhdGVFbmFibGVkIiwicGFyc2VDbGFzc1R5cGVzIiwicGFyc2VDbGFzcyIsInBhcnNlQ2xhc3NlcyIsImZpbmQiLCJjbGF6eiIsImNsYXNzR3JhcGhRTENyZWF0ZVR5cGVGaWVsZHMiLCJnZXRGaWVsZHMiLCJjbGFzc0dyYXBoUUxVcGRhdGVUeXBlRmllbGRzIiwicHJvbWlzZXMiLCJPYmplY3QiLCJrZXlzIiwibWFwIiwiZmllbGQiLCJpbnB1dFR5cGVGaWVsZCIsInR5cGUiLCJkZWZhdWx0R3JhcGhRTFR5cGVzIiwiR0VPX1BPSU5UX0lOUFVUIiwidHJhbnNmb3JtZXJzIiwiZ2VvUG9pbnQiLCJQT0xZR09OX0lOUFVUIiwicG9seWdvbiIsIkZJTEVfSU5QVVQiLCJmaWxlIiwicmVsYXRpb24iLCJ0YXJnZXRDbGFzcyIsInBvaW50ZXIiLCJQcm9taXNlIiwiYWxsIiwiQUNMIiwidXBsb2FkIiwiZmlsZUluZm8iLCJuYW1lIiwiX190eXBlIiwiUGFyc2UiLCJFcnJvciIsIkZJTEVfU0FWRV9FUlJPUiIsInZhbHVlIiwiY29vcmRpbmF0ZXMiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInBhcnNlQUNMIiwicHVibGljIiwicmVhZCIsIndyaXRlIiwidXNlcnMiLCJmb3JFYWNoIiwicnVsZSIsInVzZXJJZCIsInJvbGVzIiwicm9sZU5hbWUiLCJhdXRoIiwiaW5mbyIsIklOVkFMSURfUE9JTlRFUiIsIm9wIiwiX19vcCIsIm9wcyIsIm5lc3RlZE9iamVjdHNUb0FkZCIsImNyZWF0ZUFuZEFkZCIsImlucHV0IiwicGFyc2VGaWVsZHMiLCJvYmplY3RzTXV0YXRpb25zIiwiY3JlYXRlT2JqZWN0Iiwib2JqZWN0Iiwib2JqZWN0SWQiLCJhZGQiLCJsZW5ndGgiLCJnbG9iYWxJZE9iamVjdCIsImlkIiwicHVzaCIsIm9iamVjdHMiLCJyZW1vdmUiLCJuZXN0ZWRPYmplY3RUb0FkZCIsImNyZWF0ZUFuZExpbmsiLCJsaW5rIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBRUEsTUFBTUEsY0FBYyxHQUFHLE9BQ3JCQyxTQURxQixFQUVyQkMsTUFGcUIsRUFHckI7QUFBRUMsRUFBQUEsU0FBRjtBQUFhQyxFQUFBQSxrQkFBYjtBQUFpQ0MsRUFBQUE7QUFBakMsQ0FIcUIsS0FJbEI7QUFDSCxRQUFNO0FBQ0pDLElBQUFBLHNCQURJO0FBRUpDLElBQUFBLHNCQUZJO0FBR0pDLElBQUFBLE1BQU0sRUFBRTtBQUFFQyxNQUFBQSxlQUFGO0FBQW1CQyxNQUFBQTtBQUFuQjtBQUhKLE1BSUZOLGtCQUFrQixDQUFDTyxlQUFuQixDQUFtQ1IsU0FBbkMsQ0FKSjtBQUtBLFFBQU1TLFVBQVUsR0FBR1Isa0JBQWtCLENBQUNTLFlBQW5CLENBQWdDQyxJQUFoQyxDQUNqQkMsS0FBSyxJQUFJQSxLQUFLLENBQUNaLFNBQU4sS0FBb0JBLFNBRFosQ0FBbkI7O0FBR0EsTUFBSUQsTUFBSixFQUFZO0FBQ1YsVUFBTWMsNEJBQTRCLEdBQ2hDUCxlQUFlLElBQUlILHNCQUFuQixHQUNJQSxzQkFBc0IsQ0FBQ1csU0FBdkIsRUFESixHQUVJLElBSE47QUFJQSxVQUFNQyw0QkFBNEIsR0FDaENSLGVBQWUsSUFBSUgsc0JBQW5CLEdBQ0lBLHNCQUFzQixDQUFDVSxTQUF2QixFQURKLEdBRUksSUFITjtBQUlBLFVBQU1FLFFBQVEsR0FBR0MsTUFBTSxDQUFDQyxJQUFQLENBQVluQixNQUFaLEVBQW9Cb0IsR0FBcEIsQ0FBd0IsTUFBTUMsS0FB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QUdMdUMsUUFBQUE7QUFISyxPQUFQO0FBS0Q7QUFDRjtBQTFLa0IsQ0FBckIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUGFyc2UgZnJvbSAncGFyc2Uvbm9kZSc7XG5pbXBvcnQgeyBmcm9tR2xvYmFsSWQgfSBmcm9tICdncmFwaHFsLXJlbGF5JztcbmltcG9ydCB7IGhhbmRsZVVwbG9hZCB9IGZyb20gJy4uL2xvYWRlcnMvZmlsZXNNdXRhdGlvbnMnO1xuaW1wb3J0ICogYXMgZGVmYXVsdEdyYXBoUUxUeXBlcyBmcm9tICcuLi9sb2FkZXJzL2RlZmF1bHRHcmFwaFFMVHlwZXMnO1xuaW1wb3J0ICogYXMgb2JqZWN0c011dGF0aW9ucyBmcm9tICcuLi9oZWxwZXJzL29iamVjdHNNdXRhdGlvbnMnO1xuXG5jb25zdCB0cmFuc2Zvcm1UeXBlcyA9IGFzeW5jIChcbiAgaW5wdXRUeXBlOiAnY3JlYXRlJyB8ICd1cGRhdGUnLFxuICBmaWVsZHMsXG4gIHsgY2xhc3NOYW1lLCBwYXJzZUdyYXBoUUxTY2hlbWEsIHJlcSB9XG4pID0+IHtcbiAgY29uc3Qge1xuICAgIGNsYXNzR3JhcGhRTENyZWF0ZVR5cGUsXG4gICAgY2xhc3NHcmFwaFFMVXBkYXRlVHlwZSxcbiAgICBjb25maWc6IHsgaXNDcmVhdGVFbmFibGVkLCBpc1VwZGF0ZUVuYWJsZWQgfSxcbiAgfSA9IHBhcnNlR3JhcGhRTFNjaGVtYS5wYXJzZUNsYXNzVHlwZXNbY2xhc3NOYW1lXTtcbiAgY29uc3QgcGFyc2VDbGFzcyA9IHBhcnNlR3JhcGhRTFNjaGVtYS5wYXJzZUNsYXNzZXMuZmluZChcbiAgICBjbGF6eiA9PiBjbGF6ei5jbGFzc05hbWUgPT09IGNsYXNzTmFtZVxuICApO1xuICBpZiAoZmllbGRzKSB7XG4gICAgY29uc3QgY2xhc3NHcmFwaFFMQ3JlYXRlVHlwZUZpZWxkcyA9XG4gICAgICBpc0NyZWF0ZUVuYWJsZWQgJiYgY2xhc3NHcmFwaFFMQ3JlYXRlVHlwZVxuICAgICAgICA/IGNsYXNzR3JhcGhRTENyZWF0ZVR5cGUuZ2V0RmllbGRzKClcbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IGNsYXNzR3JhcGhRTFVwZGF0ZVR5cGVGaWVsZHMgPVxuICAgICAgaXNVcGRhdGVFbmFibGVkICYmIGNsYXNzR3JhcGhRTFVwZGF0ZVR5cGVcbiAgICAgICAgPyBjbGFzc0dyYXBoUUxVcGRhdGVUeXBlLmdldEZpZWxkcygpXG4gICAgICAgIDogbnVsbDtcbiAgICBjb25zdCBwcm9taXNlcyA9IE9iamVjdC5rZXlzKGZpZWxkcykubWFwKGFzeW5jIGZpZWxkID0+IHtcbiAgICAgIGxldCBpbnB1dFR5cGVGaWVsZDtcbiAgICAgIGlmIChpbnB1dFR5cGUgPT09ICdjcmVhdGUnICYmIGNsYXNzR3JhcGhRTENyZWF0ZVR5cGVGaWVsZHMpIHtcbiAgICAgICAgaW5wdXRUeXBlRmllbGQgPSBjbGFzc0dyYXBoUUxDcmVhdGVUeXBlRmllbGRzW2ZpZWxkXTtcbiAgICAgIH0gZWxzZSBpZiAoY2xhc3NHcmFwaFFMVXBkYXRlVHlwZUZpZWxkcykge1xuICAgICAgICBpbnB1dFR5cGVGaWVsZCA9IGNsYXNzR3JhcGhRTFVwZGF0ZVR5cGVGaWVsZHNbZmllbGRdO1xuICAgICAgfVxuICAgICAgaWYgKGlucHV0VHlwZUZpZWxkKSB7XG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgIGNhc2UgaW5wdXRUeXBlRmllbGQudHlwZSA9PT0gZGVmYXVsdEdyYXBoUUxUeXBlcy5HRU9fUE9JTlRfSU5QVVQ6XG4gICAgICAgICAgICBmaWVsZHNbZmllbGRdID0gdHJhbnNmb3JtZXJzLmdlb1BvaW50KGZpZWxkc1tmaWVsZF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpbnB1dFR5cGVGaWVsZC50eXBlID09PSBkZWZhdWx0R3JhcGhRTFR5cGVzLlBPTFlHT05fSU5QVVQ6XG4gICAgICAgICAgICBmaWVsZHNbZmllbGRdID0gdHJhbnNmb3JtZXJzLnBvbHlnb24oZmllbGRzW2ZpZWxkXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlucHV0VHlwZUZpZWxkLnR5cGUgPT09IGRlZmF1bHRHcmFwaFFMVHlwZXMuRklMRV9JTlBVVDpcbiAgICAgICAgICAgIGZpZWxkc1tmaWVsZF0gPSBhd2FpdCB0cmFuc2Zvcm1lcnMuZmlsZShmaWVsZHNbZmllbGRdLCByZXEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBwYXJzZUNsYXNzLmZpZWxkc1tmaWVsZF0udHlwZSA9PT0gJ1JlbGF0aW9uJzpcbiAgICAgICAgICAgIGZpZWxkc1tmaWVsZF0gPSBhd2FpdCB0cmFuc2Zvcm1lcnMucmVsYXRpb24oXG4gICAgICAgICAgICAgIHBhcnNlQ2xhc3MuZmllbGRzW2ZpZWxkXS50YXJnZXRDbGFzcyxcbiAgICAgICAgICAgICAgZmllbGQsXG4gICAgICAgICAgICAgIGZpZWxkc1tmaWVsZF0sXG4gICAgICAgICAgICAgIHBhcnNlR3JhcGhRTFNjaGVtYSxcbiAgICAgICAgICAgICAgcmVxXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBwYXJzZUNsYXNzLmZpZWxkc1tmaWVsZF0udHlwZSA9PT0gJ1BvaW50ZXInOlxuICAgICAgICAgICAgZmllbGRzW2ZpZWxkXSA9IGF3YWl0IHRyYW5zZm9ybWVycy5wb2ludGVyKFxuICAgICAgICAgICAgICBwYXJzZUNsYXNzLmZpZWxkc1tmaWVsZF0udGFyZ2V0Q2xhc3MsXG4gICAgICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgICAgICBmaWVsZHNbZmllbGRdLFxuICAgICAgICAgICAgICBwYXJzZUdyYXBoUUxTY2hlbWEsXG4gICAgICAgICAgICAgIHJlcVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIGlmIChmaWVsZHMuQUNMKSBmaWVsZHMuQUNMID0gdHJhbnNmb3JtZXJzLkFDTChmaWVsZHMuQUNMKTtcbiAgfVxuICByZXR1cm4gZmllbGRzO1xufTtcblxuY29uc3QgdHJhbnNmb3JtZXJzID0ge1xuICBmaWxlOiBhc3luYyAoeyBmaWxlLCB1cGxvYWQgfSwgeyBjb25maWcgfSkgPT4ge1xuICAgIGlmICh1cGxvYWQpIHtcbiAgICAgIGNvbnN0IHsgZmlsZUluZm8gfSA9IGF3YWl0IGhhbmRsZVVwbG9hZCh1cGxvYWQsIGNvbmZpZyk7XG4gICAgICByZXR1cm4geyBuYW1lOiBmaWxlSW5mby5uYW1lLCBfX3R5cGU6ICdGaWxlJyB9O1xuICAgIH0gZWxzZSBpZiAoZmlsZSAmJiBmaWxlLm5hbWUpIHtcbiAgICAgIHJldHVybiB7IG5hbWU6IGZpbGUubmFtZSwgX190eXBlOiAnRmlsZScgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFBhcnNlLkVycm9yLkZJTEVfU0FWRV9FUlJPUiwgJ0ludmFsaWQgZmlsZSB1cGxvYWQuJyk7XG4gIH0sXG4gIHBvbHlnb246IHZhbHVlID0+ICh7XG4gICAgX190eXBlOiAnUG9seWdvbicsXG4gICAgY29vcmRpbmF0ZXM6IHZhbHVlLm1hcChnZW9Qb2ludCA9PiBbZ2VvUG9pbnQubGF0aXR1ZGUsIGdlb1BvaW50LmxvbmdpdHVkZV0pLFxuICB9KSxcbiAgZ2VvUG9pbnQ6IHZhbHVlID0+ICh7XG4gICAgLi4udmFsdWUsXG4gICAgX190eXBlOiAnR2VvUG9pbnQnLFxuICB9KSxcbiAgQUNMOiB2YWx1ZSA9PiB7XG4gICAgY29uc3QgcGFyc2VBQ0wgPSB7fTtcbiAgICBpZiAodmFsdWUucHVibGljKSB7XG4gICAgICBwYXJzZUFDTFsnKiddID0ge1xuICAgICAgICByZWFkOiB2YWx1ZS5wdWJsaWMucmVhZCxcbiAgICAgICAgd3JpdGU6IHZhbHVlLnB1YmxpYy53cml0ZSxcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh2YWx1ZS51c2Vycykge1xuICAgICAgdmFsdWUudXNlcnMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgcGFyc2VBQ0xbcnVsZS51c2VySWRdID0ge1xuICAgICAgICAgIHJlYWQ6IHJ1bGUucmVhZCxcbiAgICAgICAgICB3cml0ZTogcnVsZS53cml0ZSxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodmFsdWUucm9sZXMpIHtcbiAgICAgIHZhbHVlLnJvbGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgIHBhcnNlQUNMW2Byb2xlOiR7cnVsZS5yb2xlTmFtZX1gXSA9IHtcbiAgICAgICAgICByZWFkOiBydWxlLnJlYWQsXG4gICAgICAgICAgd3JpdGU6IHJ1bGUud3JpdGUsXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlQUNMO1xuICB9LFxuICByZWxhdGlvbjogYXN5bmMgKFxuICAgIHRhcmdldENsYXNzLFxuICAgIGZpZWxkLFxuICAgIHZhbHVlLFxuICAgIHBhcnNlR3JhcGhRTFNjaGVtYSxcbiAgICB7IGNvbmZpZywgYXV0aCwgaW5mbyB9XG4gICkgPT4ge1xuICAgIGlmIChPYmplY3Qua2V5cyh2YWx1ZSkgPT09IDApXG4gICAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoXG4gICAgICAgIFBhcnNlLkVycm9yLklOVkFMSURfUE9JTlRFUixcbiAgICAgICAgYFlvdSBuZWVkIHRvIHByb3ZpZGUgYXQgbGVhc3Qgb25lIG9wZXJhdGlvbiBvbiB0aGUgcmVsYXRpb24gbXV0YXRpb24gb2YgZmllbGQgJHtmaWVsZH1gXG4gICAgICApO1xuXG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICBfX29wOiAnQmF0Y2gnLFxuICAgICAgb3BzOiBbXSxcbiAgICB9O1xuICAgIGxldCBuZXN0ZWRPYmplY3RzVG9BZGQgPSBbXTtcblxuICAgIGlmICh2YWx1ZS5jcmVhdGVBbmRBZGQpIHtcbiAgICAgIG5lc3RlZE9iamVjdHNUb0FkZCA9IChcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgdmFsdWUuY3JlYXRlQW5kQWRkLm1hcChhc3luYyBpbnB1dCA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZUZpZWxkcyA9IGF3YWl0IHRyYW5zZm9ybVR5cGVzKCdjcmVhdGUnLCBpbnB1dCwge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IHRhcmdldENsYXNzLFxuICAgICAgICAgICAgICBwYXJzZUdyYXBoUUxTY2hlbWEsXG4gICAgICAgICAgICAgIHJlcTogeyBjb25maWcsIGF1dGgsIGluZm8gfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdHNNdXRhdGlvbnMuY3JlYXRlT2JqZWN0KFxuICAgICAgICAgICAgICB0YXJnZXRDbGFzcyxcbiAgICAgICAgICAgICAgcGFyc2VGaWVsZHMsXG4gICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgYXV0aCxcbiAgICAgICAgICAgICAgaW5mb1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApLm1hcChvYmplY3QgPT4gKHtcbiAgICAgICAgX190eXBlOiAnUG9pbnRlcicsXG4gICAgICAgIGNsYXNzTmFtZTogdGFyZ2V0Q2xhc3MsXG4gICAgICAgIG9iamVjdElkOiBvYmplY3Qub2JqZWN0SWQsXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLmFkZCB8fCBuZXN0ZWRPYmplY3RzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKCF2YWx1ZS5hZGQpIHZhbHVlLmFkZCA9IFtdO1xuICAgICAgdmFsdWUuYWRkID0gdmFsdWUuYWRkLm1hcChpbnB1dCA9PiB7XG4gICAgICAgIGNvbnN0IGdsb2JhbElkT2JqZWN0ID0gZnJvbUdsb2JhbElkKGlucHV0KTtcbiAgICAgICAgaWYgKGdsb2JhbElkT2JqZWN0LnR5cGUgPT09IHRhcmdldENsYXNzKSB7XG4gICAgICAgICAgaW5wdXQgPSBnbG9iYWxJZE9iamVjdC5pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIF9fdHlwZTogJ1BvaW50ZXInLFxuICAgICAgICAgIGNsYXNzTmFtZTogdGFyZ2V0Q2xhc3MsXG4gICAgICAgICAgb2JqZWN0SWQ6IGlucHV0LFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBvcC5vcHMucHVzaCh7XG4gICAgICAgIF9fb3A6ICdBZGRSZWxhdGlvbicsXG4gICAgICAgIG9iamVjdHM6IFsuLi52YWx1ZS5hZGQsIC4uLm5lc3RlZE9iamVjdHNUb0FkZF0sXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUucmVtb3ZlKSB7XG4gICAgICBvcC5vcHMucHVzaCh7XG4gICAgICAgIF9fb3A6ICdSZW1vdmVSZWxhdGlvbicsXG4gICAgICAgIG9iamVjdHM6IHZhbHVlLnJlbW92ZS5tYXAoaW5wdXQgPT4ge1xuICAgICAgICAgIGNvbnN0IGdsb2JhbElkT2JqZWN0ID0gZnJvbUdsb2JhbElkKGlucHV0KTtcbiAgICAgICAgICBpZiAoZ2xvYmFsSWRPYmplY3QudHlwZSA9PT0gdGFyZ2V0Q2xhc3MpIHtcbiAgICAgICAgICAgIGlucHV0ID0gZ2xvYmFsSWRPYmplY3QuaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfX3R5cGU6ICdQb2ludGVyJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdGFyZ2V0Q2xhc3MsXG4gICAgICAgICAgICBvYmplY3RJZDogaW5wdXQsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wO1xuICB9LFxuICBwb2ludGVyOiBhc3luYyAoXG4gICAgdGFyZ2V0Q2xhc3MsXG4gICAgZmllbGQsXG4gICAgdmFsdWUsXG4gICAgcGFyc2VHcmFwaFFMU2NoZW1hLFxuICAgIHsgY29uZmlnLCBhdXRoLCBpbmZvIH1cbiAgKSA9PiB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlKSA+IDEgfHwgT2JqZWN0LmtleXModmFsdWUpID09PSAwKVxuICAgICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFxuICAgICAgICBQYXJzZS5FcnJvci5JTlZBTElEX1BPSU5URVIsXG4gICAgICAgIGBZb3UgbmVlZCB0byBwcm92aWRlIGxpbmsgT1IgY3JlYXRlTGluayBvbiB0aGUgcG9pbnRlciBtdXRhdGlvbiBvZiBmaWVsZCAke2ZpZWxkfWBcbiAgICAgICk7XG5cbiAgICBsZXQgbmVzdGVkT2JqZWN0VG9BZGQ7XG4gICAgaWYgKHZhbHVlLmNyZWF0ZUFuZExpbmspIHtcbiAgICAgIGNvbnN0IHBhcnNlRmllbGRzID0gYXdhaXQgdHJhbnNmb3JtVHlwZXMoJ2NyZWF0ZScsIHZhbHVlLmNyZWF0ZUFuZExpbmssIHtcbiAgICAgICAgY2xhc3NOYW1lOiB0YXJnZXRDbGFzcyxcbiAgICAgICAgcGFyc2VHcmFwaFFMU2NoZW1hLFxuICAgICAgICByZXE6IHsgY29uZmlnLCBhdXRoLCBpbmZvIH0sXG4gICAgICB9KTtcbiAgICAgIG5lc3RlZE9iamVjdFRvQWRkID0gYXdhaXQgb2JqZWN0c011dGF0aW9ucy5jcmVhdGVPYmplY3QoXG4gICAgICAgIHRhcmdldENsYXNzLFxuICAgICAgICBwYXJzZUZpZWxkcyxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBhdXRoLFxuICAgICAgICBpbmZvXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX190eXBlOiAnUG9pbnRlcicsXG4gICAgICAgIGNsYXNzTmFtZTogdGFyZ2V0Q2xhc3MsXG4gICAgICAgIG9iamVjdElkOiBuZXN0ZWRPYmplY3RUb0FkZC5vYmplY3RJZCxcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh2YWx1ZS5saW5rKSB7XG4gICAgICBsZXQgb2JqZWN0SWQgPSB2YWx1ZS5saW5rO1xuICAgICAgY29uc3QgZ2xvYmFsSWRPYmplY3QgPSBmcm9tR2xvYmFsSWQob2JqZWN0SWQpO1xuICAgICAgaWYgKGdsb2JhbElkT2JqZWN0LnR5cGUgPT09IHRhcmdldENsYXNzKSB7XG4gICAgICAgIG9iamVjdElkID0gZ2xvYmFsSWRPYmplY3QuaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfX3R5cGU6ICdQb2ludGVyJyxcbiAgICAgICAgY2xhc3NOYW1lOiB0YXJnZXRDbGFzcyxcbiAgICAgICAgb2JqZWN0SWQsXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbn07XG5cbmV4cG9ydCB7IHRyYW5zZm9ybVR5cGVzIH07XG4iXX0=